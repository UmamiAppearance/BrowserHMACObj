var BrowserHMACObj=function(){"use strict";class t extends Error{constructor(t){super(t),this.name="PermissionError"}}const e=async(t,e,s="raw",i=!1)=>await window.crypto.subtle.importKey(s,t,{name:"HMAC",hash:{name:e}},i,["sign","verify"]),s=async(t,e=!1)=>await window.crypto.subtle.generateKey({name:"HMAC",hash:{name:t}},e,["sign","verify"]),i=async(e,s="raw")=>{if(!e.extractable)throw new t("Key exports are not allowed. You can permit this during key-generation.");return await window.crypto.subtle.exportKey(s,e)},n=async(t,e)=>await window.crypto.subtle.sign({name:"HMAC",hash:e.algorithm.hash.name},e,t),r=async(t,e,s)=>await window.crypto.subtle.verify("HMAC",s,e,t),a=(t,e)=>{if(!t)throw new TypeError("Missing required parameter 'digestmod'.");let s=0|[].concat(String(t).match(/[0-9]+/)).at(0);if(t=`SHA-${s}`,!e.includes(t))throw new TypeError(`Available digestmod are: '${e.join(", ")}'.`);return 1===s&&(s=160),[t,s]};class o{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class l{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!l.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,e){let s;return s="buffer"===(e=l.getType(e))?t.buffer:"view"===e?new DataView(t.buffer):t,s}}class h{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const s=this.makeDataView(8);return s.setFloat64(0,t,e),s}static numbers(t,e=!1){let s,i;if(Number.isInteger(t)){if(i="int",!Number.isSafeInteger(t)){let e,s,i;throw t<0?(e=Number.MIN_SAFE_INTEGER,s="smaller",i="MIN"):(e=Number.MAX_SAFE_INTEGER,s="bigger",i="MAX"),new RangeError(`The provided integer is ${s} than ${i}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(s=this.makeDataView(8),s.setBigInt64(0,BigInt(t),e)):t<-32768?(s=this.makeDataView(4),s.setInt32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):t>0?t>4294967295?(s=this.makeDataView(8),s.setBigUint64(0,BigInt(t),e)):t>65535?(s=this.makeDataView(4),s.setUint32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):s=new Uint16Array([0])}else i="float",s=this.floatingPoints(t,e);return[new Uint8Array(s.buffer),i]}static bigInts(t,e=!1){const s=new Array,i=e?"push":"unshift",n=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)s[i](t%n),t>>=64n;else for(;t>=n;)s[i](t%n),t>>=64n;s[i](t);const r=8*s.length,a=this.makeDataView(r);return s.forEach(((t,s)=>{const i=8*s;a.setBigUint64(i,t,e)})),new Uint8Array(a.buffer)}static toBytes(t,e){let s,i=!1,n="bytes";if(t instanceof ArrayBuffer)s=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))s=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)s=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(i=!0,t=-t),e.numberMode){const i=this.floatingPoints(t,e.littleEndian);s=new Uint8Array(i.buffer),n="float"}else[s,n]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(i=!0,t*=-1n),s=this.bigInts(t,e.littleEndian),n="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const i=new Array;for(const s of t)i.push(...this.toBytes(s,e)[0]);s=Uint8Array.from(i)}}return[s,i,n]}}class u{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,s,i){const n=t.byteLength,r=(e-t.byteLength%e)%e,a=i&&n>1?255:0;let o=t;if(r){o=new Uint8Array(n+r),o.fill(a);const e=s?0:r;o.set(t,e)}return o.buffer}static makeTypedArray(t,e,s,i){let n;if("int16"===e||"uint16"===e){const r=this.makeTypedArrayBuffer(t,2,s,i);n="int16"===e?new Int16Array(r):new Uint16Array(r)}else if("int32"===e||"uint32"===e||"float32"===e){const r=this.makeTypedArrayBuffer(t,4,s,i);n="int32"===e?new Int32Array(r):"uint32"===e?new Uint32Array(r):new Float32Array(r)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const r=this.makeTypedArrayBuffer(t,8,s,i);n="bigint64"===e?new BigInt64Array(r):"biguint64"===e?new BigUint64Array(r):new Float64Array(r)}return n}static compile(t,e,s=!1,i=!1){let n;if(e=this.getType(e),i){let i;if(i=e.match(/^float/)?-this.compile(t,"float_n",s):-this.compile(t,"uint_n",s),"float_n"===e)return i;t=h.toBytes(i,{littleEndian:s,numberMode:!1,signed:!1})[0]}if("buffer"===e)n=t.buffer;else if("bytes"===e||"uint8"===e)n=t;else if("int8"===e)n=new Int8Array(t.buffer);else if("view"===e)n=new DataView(t.buffer);else if("str"===e)n=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,s,i);t=new Uint8Array(e)}s&&t.reverse();let r=0n;t.forEach((t=>r=(r<<8n)+BigInt(t))),"uint_n"!==e&&(r=BigInt.asIntN(8*t.length,r)),n="bigint_n"!==e&&r>=Number.MIN_SAFE_INTEGER&&r<=Number.MAX_SAFE_INTEGER?Number(r):r}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,i);n=new DataView(e.buffer).getFloat32(0,s)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,i);n=new DataView(e.buffer).getFloat64(0,s)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);n=Number(e)}else n=this.makeTypedArray(t,e,s,i);return n}}const c=h,d=u;class p{constructor(t,e=!0){this.root=t,"charsets"in t&&e&&this.#t()}setIOHandlers(t=c,e=d){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const s=this.root.converter.radix;let i=s;if("string"==typeof e||Array.isArray(e))i=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==s)throw i===s?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The length of the charset must be ${s}.`);e=[...e].join(""),this.root.charsets[t]=e,console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{({version:t}=this.validateArgs([t])),this.root.version=t}}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}invalidArgument(t,e,s,i){const n=i?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",r=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",a=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",o=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",l=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",h=`\n * valid args for the output type are ${this.makeArgList(s)}`,u=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"";throw new TypeError(`'${t}'\n\nInput parameters:${n}${r}${a}${o}${l}${h}${u}\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)\n\nTraceback:`)}validateArgs(t,e=!1){const s={littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};if(!t.length)return e&&this.setIOHandlers(),s;const i=e=>!!t.includes(e)&&(t.splice(t.indexOf(e),1),!0),n=Object.prototype.hasOwnProperty.call(this.root,"charsets")?Object.keys(this.root.charsets):[],r={littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"]};if(e)if(i("bytes_only"))this.setIOHandlers(o,l);else{const t=i("bytes_in")?o:c,e=i("bytes_out")?l:d;this.setIOHandlers(t,e)}const a=this.outputHandler.typeList;if(i("number")&&(s.numberMode=!0,s.outputType="float_n"),t.forEach((t=>{if(t=String(t).toLowerCase(),n.includes(t))s.version=t;else if(a.includes(t))s.outputType=t;else{let i=!0;for(const e in r)if(r[e].includes(t)){if(i=!1,!this.root.isMutable[e])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);s[e]=Boolean(r[e].indexOf(t))}i&&this.invalidArgument(t,n,a,e)}})),s.padding&&s.signed&&(s.padding=!1,this.constructor.warning("Padding was set to false due to the signed conversion.")),e)for(const t in s)this.root[t]=s[t];return s}signError(){throw new TypeError("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter.")}static warning(t){Object.prototype.hasOwnProperty.call(console,"warn")?console.warn(t):console.log(`___\n${t}\n`)}}class f{constructor(t,e=null,s=null,i=0){this.radix=t,null!==e&&null!==s?(this.bsEnc=e,this.bsDec=s):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=i}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let s=0;for(;8*s*Math.log(2)/Math.log(t)<e;)s++;return[s,Math.ceil(8*s*Math.log(2)/Math.log(t))]}encode(t,e,s=!1,i=null){let n=this.bsEnc;0===n&&(n=t.byteLength);let r="";const a=n?(n-t.length%n)%n:0,o=new Array(a).fill(0);let l;if(s?(t.reverse(),l=[...o,...t]):l=[...t,...o],10===this.radix){let t=0n;for(let e=0;e<n;e++)t=(t<<8n)+BigInt(l[e]);return[t.toString(),0]}for(let t=0,s=l.length;t<s;t+=n){let s=0n;for(let e=t;e<t+n;e++)s=(s<<8n)+BigInt(l[e]);const o=new Array;let h,u=s;for(;u>=this.radix;)[u,h]=this.divmod(u,this.radix),o.unshift(parseInt(h,10));for(o.unshift(parseInt(u,10));o.length<this.bsDec;)o.unshift(0);let c="";o.forEach((t=>c=c.concat(e[t]))),i&&(c=i(c,a)),r=r.concat(c)}return[r,a]}decode(t,e,s=!1){if(!t)return new Uint8Array(0);let i=this.bsDec;const n=new Array;let r;if(t.split("").forEach((t=>{const s=e.indexOf(t);s>-1&&n.push(s)})),0===i)i=n.length;else{r=(i-n.length%i)%i;const t=new Array(r).fill(this.decPadVal);s?n.unshift(...t):n.push(...t)}let a=new Array;for(let t=0,e=n.length;t<e;t+=i){let e=0n;for(let s=0;s<i;s++)e+=BigInt(n[t+s])*this.pow(i-1-s);const s=new Array;let r,o=e;for(;o>=256;)[o,r]=this.divmod(o,256),s.unshift(parseInt(r,10));for(s.unshift(parseInt(o,10));s.length<this.bsEnc;)s.unshift(0);a=a.concat(s)}if(s){if(a.length>1){for(;!a[0];)a.shift();a.length||a.push(0),a.reverse()}}else if(this.bsDec){const t=this.padChars(r);a.splice(a.length-t)}return Uint8Array.from(a)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class g{constructor(t=!0){this.charsets={},this.hasSignedMode=!1,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,t&&(this.utils=new p(this)),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,s,...i){const n=this.utils.validateArgs(i);let r,a,o;[r,a,o]=this.utils.inputHandler.toBytes(t,n);let l,h,u=null;return e&&(u=e(n)),[l,h]=this.converter.encode(r,this.charsets[n.version],n.littleEndian,u),n.signed&&(l=this.utils.toSignedStr(l,a)),n.upper&&(l=l.toUpperCase()),s&&(l=s({inputBytes:r,output:l,settings:n,zeroPadding:h,type:o})),l}decode(t,e,s,...i){const n=this.utils.validateArgs(i);let r=String(t),a=!1;this.hasSignedMode&&([r,a]=this.utils.extractSign(r),a&&!n.signed&&this.utils.signError()),this.isMutable.upper&&(r=r.toLowerCase()),e&&(r=e({input:r,settings:n}));let o=this.converter.decode(r,this.charsets[n.version],n.littleEndian);return s&&(o=s({input:r,output:o,settings:n})),this.utils.outputHandler.compile(o,n.outputType,n.littleEndian,a)}}class y extends g{constructor(...t){super(),delete this.addCharset,this.charsets.all=" !\"#$%&'()*+,./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",this.charsets.sequence="Hello World!",this.charsets.default="1",this.charsets.tmark="|#",this.converter=new f(10,0,0),this.hasSignedMode=!0,this.littleEndian=!0,this.signed=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n;[i,n]=this.utils.inputHandler.toBytes(t,s);let r=this.converter.encode(i,null,s.littleEndian)[0],a=BigInt(r);if(a>Number.MAX_SAFE_INTEGER)throw new RangeError("Invalid string length.");a>16777216&&this.utils.constructor.warning("The string length is really long. The JavaScript engine may have memory issues generating the output string."),a=Number(a);const o=this.charsets[s.version],l=o.length;let h="";if(1===l)h=o.repeat(a);else if("all"===s.version)for(let t=0;t<a;t++){h+=o[Math.floor(Math.random()*l)]}else if("tmark"===s.version){const t=a%5;a>4&&(h=o[1].repeat((a-t)/5)),h+=o[0].repeat(t)}else for(let t=0;t<a;t++)h+=o[t%l];return h=this.utils.toSignedStr(h,n),s.upper&&(h=h.toUpperCase()),h}decode(t,...e){const s=this.utils.validateArgs(e);let i;if(t=String(t),[t,i]=this.utils.extractSign(t),"all"!==s.version){const e=[...new Set(this.charsets[s.version])].join(""),i=new RegExp(`[^${e}]`,"g");t=t.replace(i,"")}t=String(t.length);const n=this.converter.decode(t,"0123456789",s.littleEndian);return this.utils.outputHandler.compile(n,s.outputType,s.littleEndian,i)}}class w extends g{constructor(...t){super(),this.converter=new f(16,1,2),this.charsets.default="0123456789abcdef",this.hasSignedMode=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e}=t;return e=e.replace(/^0x/,""),e.length%2&&(e="0".concat(e)),e}),null,...e)}}class b extends g{constructor(...t){super(),this.charsets.crockford="0123456789abcdefghjkmnpqrstvwxyz",this.charsets.rfc3548="abcdefghijklmnopqrstuvwxyz234567",this.charsets.rfc4648="0123456789abcdefghijklmnopqrstuv",this.charsets.zbase32="ybndrfg8ejkmcpqxot1uwisza345h769",this.converter=new f(32,5,8),this.hasSignedMode=!0,this.padding=!0,this.version="rfc4648",this.isMutable.littleEndian=!0,this.isMutable.padding=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(!s.littleEndian&&i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t),s.padding&&(e=e.concat("=".repeat(t)))}return e}),...e)}decode(t,...e){return super.decode(t,null,null,...e)}}class m extends g{constructor(...t){super(),this.charsets.default="123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",this.charsets.bitcoin="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",this.charsets.flickr="123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",this.converter=new f(58,0,0),this.padding=!0,this.version="bitcoin",this.isMutable.padding=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{inputBytes:e,output:s,settings:i,type:n}=t;if(i.padding&&"int"!==n){let t=0;const i=e.length;if(i){for(;!e[t];)if(t++,t===i){t=0;break}const n=t;n&&(s="1".repeat(n).concat(s))}}return s}),...e)}decode(t,...e){return super.decode(t,null,(t=>{let{input:e,output:s,settings:i}=t;if(i.padding&&e.length>1){let t=0;for(;"1"===e[t];)t++;const i=t;i&&(s=Uint8Array.from([...new Array(i).fill(0),...s]))}return s}),...e)}}class v extends g{constructor(...t){super();const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";this.charsets.default=e.concat("+/"),this.charsets.urlsafe=e.concat("-_"),this.converter=new f(64,3,4),this.padding=!0,this.isMutable.padding=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t),s.padding&&(e=e.concat("=".repeat(t)))}return e}),...e)}decode(t,...e){return super.decode(t,null,null,...e)}}class A extends g{constructor(...t){super(),this.charsets.adobe="!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu",this.charsets.ascii85=this.charsets.adobe,this.charsets.rfc1924="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~",this.charsets.z85="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#",this.converter=new f(85,4,5,84),this.version="ascii85",this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,(t=>{let e;return t.version.match(/adobe|ascii85/)&&(e=(t,e)=>e||"!!!!!"!==t?t:"z"),e}),(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t)}return"adobe"===s.version&&(e=`<~${e}~>`),e}),...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e,settings:s}=t;return s.version.match(/adobe|ascii85/)&&(e=e.replace(/z/g,"!!!!!"),"adobe"===s.version&&(e=e.replace(/^<~|~>$/g,""))),e}),null,...e)}}class E extends g{constructor(...t){super(),this.charsets.default='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"',this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e),i=this.utils.inputHandler.toBytes(t,s)[0];let n=0,r=0,a="";const o=this.charsets[s.version];if(i.forEach((t=>{if(r+=t<<n,n+=8,n>13){let t,e,s=13,i=r%8192;i<89&&(s=14,i=r%16384),r>>=s,n-=s,[t,e]=this.divmod(i,91),a=`${a}${o[e]}${o[t]}`}})),n){let t,e;[t,e]=this.divmod(r,91),a=a.concat(o[e]),(n>7||r>90)&&(a=a.concat(o[t]))}return a}decode(t,...e){const s=this.utils.validateArgs(e);let i=(t=String(t)).length,n=!1;i%2&&(n=!0,i--);let r=0,a=0;const o=this.charsets[s.version],l=new Array;for(let e=0;e<i;e+=2){const s=o.indexOf(t[e])+91*o.indexOf(t[e+1]);r=(s<<a)+r,a+=s%8192>88?13:14;do{l.push(r%256),r>>=8,a-=8}while(a>7)}if(n){const e=t.charAt(i),s=o.indexOf(e);l.push(((s<<a)+r)%256)}const h=Uint8Array.from(l);return this.utils.outputHandler.compile(h,s.outputType)}divmod(t,e){return[Math.floor(t/e),t%e]}}class k{constructor(...t){this.littleEndian=!0,this.numberMode=!1,this.outputType="buffer",this.utils={validateArgs:(t,e=!1)=>{const s={littleEndian:this.littleEndian,numberMode:this.numberMode,outputType:this.outputType,signed:!1};if(!t.length)return s;t.includes("number")&&(t.splice(t.indexOf("number"),1),s.numberMode=!0,s.outputType="float_n");const i=u.typeList.map((t=>`'${t}'`)).join(", ");if(t.forEach((t=>{if("le"===(t=String(t).toLowerCase()))s.littleEndian=!0;else if("be"===t)s.littleEndian=!1;else{if(!u.typeList.includes(t))throw new TypeError(`Invalid argument: '${t}.\nValid arguments are:\n'le', 'be', ${i}`);s.outputType=t}})),e)for(const t in s)this[t]=s[t];return s}},this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);return h.toBytes(t,s)[0]}decode(t,...e){const s=this.utils.validateArgs(e);return u.compile(t,s.outputType,s.littleEndian)}}class T extends g{constructor(...t){super(!1),this.charsets.default="<placeholder>",this.charsets.hex="<placeholder>",this.version="default",this.converter=new f(10,0,0),this.hexlify=new f(16,1,2),this.utils=new p(this,!1),this.littleEndian=!0,this.hasSignedMode=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n;const r=s.signed;s.signed=!0,[i,n]=this.utils.inputHandler.toBytes(t,s);let a=this.converter.encode(i,null,s.littleEndian)[0],o=BigInt(a),l=new Array;if(n){if(!r)throw new TypeError("Negative values in unsigned mode are invalid.");o=-o}if(r)for(;;){const t=Number(127n&o);if(o>>=7n,0==o&&0==(64&t)||-1==o&&0!=(64&t)){l.push(t);break}l.push(128|t)}else for(;;){const t=Number(127n&o);if(o>>=7n,0==o){l.push(t);break}l.push(128|t)}const h=Uint8Array.from(l);return"hex"===s.version?this.hexlify.encode(h,"0123456789abcdef",!1)[0]:h}decode(t,...e){const s=this.utils.validateArgs(e);if("hex"===s.version?t=this.hexlify.decode(String(t).toLowerCase(),"0123456789abcdef",!1):t instanceof ArrayBuffer&&(t=new Uint8Array(t)),1===t.length&&!t[0])return this.utils.outputHandler.compile(new Uint8Array(1),s.outputType,!0);t=Array.from(t);let i,n,r,a=0n,o=-7n;for(i of t)o+=7n,a+=BigInt(127&i)<<o;s.signed&&0!=(64&i)&&(a|=-(1n<<o+7n)),[n,r]=this.utils.extractSign(a.toString());const l=this.converter.decode(n,"0123456789",!0);return this.utils.outputHandler.compile(l,s.outputType,!0,r)}}class B extends g{constructor(t,...e){if(super(),!t||!Number.isInteger(t)||t<2||t>36)throw new RangeError("Radix argument must be provided and has to be an integer between 2 and 36.");this.charsets.default="0123456789abcdefghijklmnopqrstuvwxyz".substring(0,t),this.converter=new f(t,0,0),this.hasSignedMode=!0,this.littleEndian=!(2===t||16===t),this.signed=!0,this.version="default",this.isMutable.littleEndian=!0,this.isMutable.upper=!0,this.utils.validateArgs(e,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e}=t;if(2===this.converter.radix){const t=(8-e.length%8)%8;e=`${"0".repeat(t)}${e}`}else if(16===this.converter.radix){const t=e.length%2;e=`${"0".repeat(t)}${e}`}return e}),null,...e)}}
/**
     * [BaseEx]{@link https://github.com/UmamiAppearance/BaseExJS}
     *
     * @version 0.4.3
     * @author UmamiAppearance [mail@umamiappearance.eu]
     * @license GPL-3.0 AND BSD-3-Clause (only regarding Base91, Copyright (c) 2000-2006 Joachim Henke)
     */
/**
     * [BrowserHMACObj]{@link https://github.com/UmamiAppearance/BrowserHMACObj}
     *
     * @version 0.1.1
     * @author UmamiAppearance [mail@umamiappearance.eu]
     * @license GPL-3.0
     */
const M=["SHA-1","SHA-256","SHA-384","SHA-512"],I=new class{constructor(t="buffer"){if(!d.typeList.includes(t)){let e=`Invalid argument '${t}' for output type. Allowed types are:\n`;throw e=e.concat(d.typeList.join(", ")),new TypeError(e)}this.base1=new y("default",t),this.base16=new w("default",t),this.base32_crockford=new b("rfc4648",t),this.base32_rfc3548=new b("rfc3548",t),this.base32_rfc4648=new b("rfc4648",t),this.base32_zbase32=new b("zbase32",t),this.base58=new m("default",t),this.base58_bitcoin=new m("bitcoin",t),this.base58_flickr=new m("flickr",t),this.base64=new v("default",t),this.base64_urlsafe=new v("urlsafe",t),this.base85_adobe=new A("adobe",t),this.base85_ascii=new A("ascii85",t),this.base85_z85=new A("z85",t),this.base91=new E("default",t),this.leb128=new T("default",t),this.byteConverter=new k(t),this.simpleBase={};for(let e=2;e<37;e++)this.simpleBase[`base${e}`]=new B(e,t)}},x=["raw","jwk"];return class{#e=null;#s=null;#i=null;#n=[];#r=null;#a=this.constructor.keyFormats();#o=null;constructor(t){[this.#i,this.#e]=a(t,M),this.#l()}static baseEx=I;static digestmodsAvailable(){return new Set(M)}static keyFormats(){return new Set(x)}static async generateKey(t="",e=!1){return t=a(t,M).at(0),await s(t,e)}static compareDigest(t,e){if(void 0===t||void 0===e)throw new Error("BrowserSHAobj.compareDigest takes exactly two positional arguments.");let s,i;t=I.byteConverter.encode(t,"uint8"),e=I.byteConverter.encode(e,"uint8"),t.byteLength>e.byteLength?(s=t,i=e):(s=e,i=t);const n=s.map(((t,e)=>t===i.at(e)));return Boolean(n.reduce(((t,e)=>t*e)))}static async new(t=null,e=null,s="",i="raw",n=!1){const r=new this(s);return t&&("object"===i?await r.setKey(t):await r.importKey(t,i,n)),null!==e&&(t||(await r.generateKey(),console.warn("A message but no key was provided. The key was generated for you.")),await r.update(e)),r}get digestSize(){return this.#e/8}get blockSize(){return this.#e>256?128:64}get name(){return"HMAC-"+this.#i}#h(t){return I.byteConverter.encode(t,"bytes")}#u(t){if(!this.#a.has(t))throw new TypeError(`Invalid key format '${t}'\n\nValid formats are: ${x.join(", ")}`)}#c(){if(null===this.#r)throw new Error("No key is assigned yet. Import or generate key.")}#d(t,e){const s="Invalid base conversion keyword.";var i;if(i=e.replace(/^to/,""),"hex"===(e=i.charAt(0).toLowerCase().concat(i.slice(1)))||"hexdigest"==e)e="base16";else if("bytes"===e)e="byteConverter";else if(/SimpleBase/i.test(e)){if(!((e="base"+(0|[].concat(String(e).match(/[0-9]+/)).at(0)))in I.simpleBase))throw new TypeError(s);return I.simpleBase[e].encode(t)}if(!(e in I))throw new TypeError(s);return I[e].encode(t)}async update(t,e=!1){t=this.#h(t),this.#c(),this.#n=e?Array.from(t):this.#n.concat(Array.from(t)),this.#s=await n(Uint8Array.from(this.#n),this.#r)}async replace(t){await this.update(t,!0)}async setKey(t){this.#r=t,this.#n.length&&(console.warn("A new crypto key was established. A fresh digest is now getting calculated."),this.#s=await n(Uint8Array.from(this.#n),this.#r))}async importKey(t,s="raw",i=!1){"raw"===s?t=this.#h(t):this.#u(s),this.#o=i;const n=await e(t,this.#i,s,i);await this.setKey(n)}async generateKey(t=!0){this.#o=Boolean(t);const e=await s(this.#i,this.#o);await this.setKey(e)}async exportKey(e="raw"){if(this.#u(e),null===this.#r)throw new Error("Key is unset.");if(!this.#o)throw new t("Key exports are not allowed. You have to permit this before key-generation.");return await i(this.#r,e)}async copy(){return await this.constructor.new(this.#r,this.#n.length?Uint8Array.from(this.#n):null,this.#i,"object",this.#o)}async sign(t,e=null){this.#c(),t=this.#h(t);const s=await n(t,this.#r);return null!==e?this.#d(s,e):s}async verify(t,e){if(t=this.#h(t),this.#c(),null===this.signature)throw new TypeError("Signature must be provided");return await r(t,e,this.#r)}digest(){return this.#s}#l(){const t=(t,e)=>t.splice(t.indexOf(e),1),e=t=>t.charAt(0).toUpperCase().concat(t.slice(1));this.hexdigest=()=>this.#s?I.base16.encode(this.#s):null;const s=Object.keys(I);this.basedigest={toSimpleBase:{}},t(s,"base1"),t(s,"byteConverter"),t(s,"simpleBase");for(const t of s)this.basedigest[`to${e(t)}`]=(...e)=>this.#s?I[t].encode(this.#s,...e):null;for(const t in I.simpleBase)this.basedigest.toSimpleBase[e(t)]=(...e)=>this.#s?I.simpleBase[t].encode(this.#s,...e):null;this.basedigest.toBytes=(...t)=>this.#s?I.byteConverter.encode(this.#s,...t):null}}}();
